<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lane Clash — Menu, Play, Encyclopedia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0e1220; --panel:#161b2e; --ink:#e9f1ff; --muted:#a9b7ff;
      --line:#24315c; --accent:#70d6ff;
      --blue:#58a6ff; --red:#ff6b6b; --gold:#ffd166;
      --river:#0e3a69; --riverHi:#13518f; --bridge:#6d5538;
      --lane:#1e2a5c; --laneCtr:#28377a;
      --ok:#6bff95; --warn:#ffd166; --bad:#ff7b7b;
    }
    *{ box-sizing:border-box; }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--ink); font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    header{ padding:12px; background:#11162b; border-bottom:1px solid var(--line); position:sticky; top:0; z-index:5; }
    .title{ font-weight:750; letter-spacing:.2px; }
    main{ max-width:1024px; margin:24px auto; padding:0 12px; }
    .panel{ background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:16px; }
    .center{ display:flex; flex-direction:column; align-items:center; gap:18px; margin-top:8vh; text-align:center; }
    .muted{ color:var(--muted); }
    .hidden{ display:none; pointer-events:none; }

    .btn{
      appearance:none; border:1px solid var(--line); background:linear-gradient(180deg,#203061,#18244b);
      color:var(--ink); padding:10px 16px; border-radius:12px; font-weight:600; cursor:pointer;
      transition:transform .08s ease, filter .12s ease, box-shadow .12s ease;
    }
    .btn:hover{ transform:translateY(-1px); filter:brightness(1.05); }

    .brand{
      font-weight:900; font-size:44px; line-height:1;
      background: linear-gradient(90deg, #70d6ff, #6bff95, #ffd166);
      -webkit-background-clip:text; background-clip:text; color: transparent;
      letter-spacing: .6px; text-shadow: 0 2px 20px rgba(112,214,255,.15);
    }
    .subtitle{ color:#9fb4ff; margin-top:-6px; }

    /* Encyclopedia */
    .entries{ display:grid; gap:16px; }
    .entry{
      display:grid; grid-template-columns:min(360px,45%) 1fr; gap:18px; align-items:center;
      background:#0f1530; border:1px solid #27305a; border-radius:14px; padding:14px;
    }
    @media (max-width: 720px){ .entry{ grid-template-columns:1fr; } }
    .cardFrame{ display:flex; align-items:center; justify-content:center; padding:8px; background:transparent; border-radius:12px; min-height:220px; }
    .cardFrame img{ width:100%; height:auto; display:block; }
    .details h2{ margin:0 0 8px; font-size:22px; display:flex; align-items:center; gap:8px; }
    .pill{ display:inline-block; padding:2px 10px; border-radius:999px; background:#0b1433; border:1px solid #20306a; font-size:12px; }
    .grid{ display:grid; grid-template-columns:120px 1fr; gap:8px 12px; margin:8px 0 10px; }
    .label{ color:#9fb4ff; }
    .desc{ color:#cfe1ff; }

    /* Play */
    canvas{ width:100%; height:720px; display:block; border-radius:12px; background:#0b1026; border:1px solid #27305a; }
    .toolbar{ display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; }

    /* Card HUD */
    .cardhud{ margin-top:12px; background:#0f1530; border:1px solid #27305a; border-radius:14px; padding:10px; }
    .elixirRow{ display:flex; align-items:center; gap:12px; margin-bottom:8px; }
    .elixirBar{ position:relative; height:14px; flex:1; border:1px solid #2c355c; border-radius:999px; background:#0b0f1c; overflow:hidden; }
    .elixirFill{ position:absolute; inset:0; transform-origin:left center; background:linear-gradient(90deg,#2b68ff,#70d6ff); transform:scaleX(0); }
    .elixirText{ font-variant-numeric: tabular-nums; min-width:2ch; text-align:right; color:#cfe1ff; }
    .cards{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
    .cardBtn{
      display:flex; gap:10px; align-items:center; padding:8px; border-radius:12px; cursor:pointer;
      border:1px solid #27305a; background:linear-gradient(180deg,#152045,#111a3a);
      transition: transform .08s ease, box-shadow .12s ease, filter .12s ease, border-color .12s ease;
    }
    .cardBtn:hover{ transform: translateY(-1px); filter: brightness(1.05); box-shadow:0 8px 20px rgba(112,214,255,.12); }
    .cardBtn.selected{ outline:2px solid #70d6ff; border-color:#70d6ff; }
    .thumb{ width:56px; height:72px; border-radius:10px; background:#0b1433; border:1px solid #20306a; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .thumb img{ width:100%; height:auto; display:block; }
    .meta{ display:flex; flex-direction:column; gap:3px; }
    .name{ font-weight:700; }
    .cost{ font-size:12px; color:#b9c8ff; }
    .disabled{ opacity:.45; filter:grayscale(35%); cursor:not-allowed; }
  </style>
</head>
<body>
  <header><div class="title">Lane Clash — Prototype</div></header>

  <main>
    <!-- MENU -->
    <section id="menu" class="panel center" aria-labelledby="menuTitle">
      <h1 id="menuTitle" class="brand">Lane Clash</h1>
      <div class="subtitle">A tiny lane strategy prototype</div>
      <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:8px;">
        <button id="playBtn" class="btn">Play</button>
        <button id="openEncy" class="btn" aria-controls="ency" aria-expanded="false">Encyclopedia</button>
      </div>
      <p class="muted">Blue (you) at the bottom. Red (AI) at the top.</p>
    </section>

    <!-- PLAY -->
    <section id="play" class="panel hidden" aria-labelledby="playTitle">
      <div class="toolbar">
        <h2 id="playTitle" style="margin:0;">Play — Blue (You) at Bottom vs Red (AI) at Top</h2>
        <button id="backFromPlay" class="btn">Back</button>
      </div>

      <canvas id="game" width="960" height="720" aria-label="Battlefield"></canvas>

      <div class="cardhud" aria-label="Card and Elixir HUD">
        <div class="elixirRow">
          <span style="color:#9fb4ff;">Elixir</span>
          <div class="elixirBar"><div id="elixirFill" class="elixirFill"></div></div>
          <span id="elixirText" class="elixirText">0</span>
        </div>
        <div id="cards" class="cards"></div>
        <p class="muted" style="margin:6px 2px 0;">Click a card, then click your half of the arena to deploy. Hand shows 2 rotating cards out of 3.</p>
        <p class="muted" style="margin:6px 2px 0;">Tower stats — King: 2000 HP, 50 / 1s (wakes after first damage). Crossbow: 1000 HP, 30 / 1s.</p>
      </div>
    </section>

    <!-- ENCYCLOPEDIA -->
    <section id="ency" class="panel hidden" aria-labelledby="encyTitle">
      <div class="toolbar">
        <h2 id="encyTitle" style="margin:0;">Encyclopedia</h2>
        <button id="backBtn" class="btn">Back</button>
      </div>
      <div class="entries">
        <!-- Knight -->
        <article class="entry" aria-labelledby="knightTitle">
          <div class="cardFrame">
            <img src="assets/Knight.png" alt="Knight card (Common, Cost 2)" onerror="this.alt='Knight card image not found'; this.style.opacity=.6;">
          </div>
          <div class="details">
            <h2 id="knightTitle">Knight <span class="pill">Common</span></h2>
            <div class="grid">
              <div class="label">Elixir Cost</div><div>2</div>
              <div class="label">HP</div><div>100</div>
              <div class="label">DMG</div><div>20 / 1s</div>
              <div class="label">Speed</div><div>1</div>
              <div class="label">Unit Count</div><div>1</div>
            </div>
            <p class="desc">A brave melee fighter with balanced stats—reliable on the field.</p>
          </div>
        </article>
        <!-- Archers -->
        <article class="entry" aria-labelledby="archersTitle">
          <div class="cardFrame" style="border:1px dashed #27305a;">
            <img src="assets/Archers.png" alt="Archers card (Common, Cost 2)"
                 onerror="this.replaceWith(Object.assign(document.createElement('span'),{textContent:'Archers card art coming soon',className:'muted'}));">
          </div>
          <div class="details">
            <h2 id="archersTitle">Archers <span class="pill">Common</span></h2>
            <div class="grid">
              <div class="label">Elixir Cost</div><div>2</div>
              <div class="label">HP</div><div>60</div>
              <div class="label">DMG</div><div>15 / 0.5s</div>
              <div class="label">Speed</div><div>1.5</div>
              <div class="label">Unit Count</div><div>2</div>
            </div>
            <p class="desc">Ranged pair that pepper foes from afar—fragile but efficient.</p>
          </div>
        </article>
        <!-- Mini-MEGA -->
        <article class="entry" aria-labelledby="miniMegaTitle">
          <div class="cardFrame" style="border:1px dashed #27305a;">
            <img src="assets/Mini-MEGA.png" alt="Mini-MEGA card (Common, Cost 3)"
                 onerror="this.replaceWith(Object.assign(document.createElement('span'),{textContent:'Mini-MEGA card art coming soon',className:'muted'}));">
          </div>
          <div class="details">
            <h2 id="miniMegaTitle">Mini-MEGA <span class="pill">Common</span></h2>
            <div class="grid">
              <div class="label">Elixir Cost</div><div>3</div>
              <div class="label">HP</div><div>300</div>
              <div class="label">DMG</div><div>80 / 1.5s</div>
              <div class="label">Speed</div><div>0.75</div>
              <div class="label">Unit Count</div><div>1</div>
            </div>
            <p class="desc">Compact robot with a heavy punch. Slow stride, high impact.</p>
          </div>
        </article>
      </div>
    </section>
  </main>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    "use strict";

    /* ---------- Scene switching ---------- */
    const menuSection = document.getElementById('menu');
    const playSection = document.getElementById('play');
    const encySection = document.getElementById('ency');
    const playBtn = document.getElementById('playBtn');
    const backFromPlay = document.getElementById('backFromPlay');
    const openEncy = document.getElementById('openEncy');
    const backBtn = document.getElementById('backBtn');

    function show(el){ [menuSection, playSection, encySection].forEach(s => s.classList.add('hidden')); el.classList.remove('hidden'); window.scrollTo(0,0); }
    playBtn.addEventListener('click', () => show(playSection));
    backFromPlay.addEventListener('click', () => show(menuSection));
    openEncy.addEventListener('click', () => show(encySection));
    backBtn.addEventListener('click', () => show(menuSection));

    /* ---------- Canvas ---------- */
    const canv = document.getElementById('game');
    const ctx = canv.getContext('2d');
    const W = canv.width, H = canv.height;

    // Battlefield layout
    const riverY = H/2, riverH = 100;
    const lanesX = [ W*0.33, W*0.67 ];
    const bridgeW = 120, bridgeH = riverH + 18;

    // Elixir
    const ELIXIR_MAX = 10, ELIXIR_PER_SEC = 0.5; // 1 per 2s
    const elixir = { blue: 5, red: 5 };
    const elixirFill = document.getElementById('elixirFill');
    const elixirText = document.getElementById('elixirText');

    // Cards (2-of-3)
    const allCards = [
      { id:'knight',   name:'Knight',    cost:2, img:'assets/Knight.png',   count:1, hp:100, dmg:20, atk:1.0, range:22,  speed:60, radius:13, type:'melee' },
      { id:'archers',  name:'Archers',   cost:2, img:'assets/Archers.png',  count:2, hp:60,  dmg:15, atk:0.5, range:200, speed:90, radius:10, type:'ranged' },
      { id:'minimega', name:'Mini-MEGA', cost:3, img:'assets/Mini-MEGA.png',count:1, hp:300, dmg:80, atk:1.5, range:26,  speed:45, radius:15, type:'melee' },
    ];
    let deckOrder = shuffle([0,1,2]);
    let hand = [ deckOrder[0], deckOrder[1] ];
    let selectedHandSlot = null;

    const cardsRoot = document.getElementById('cards');
    function renderCardBar(){
      cardsRoot.innerHTML = '';
      hand.forEach((idx, slot)=>{
        const c = allCards[idx];
        const btn = document.createElement('button');
        btn.className = 'cardBtn' + (selectedHandSlot===slot?' selected':'');
        btn.type='button';
        btn.title = `${c.name} — Cost ${c.cost}`;
        btn.addEventListener('click', ()=>{ selectedHandSlot = (selectedHandSlot===slot? null : slot); refreshElixirUI(); });
        const thumb = document.createElement('div'); thumb.className='thumb';
        const img = document.createElement('img'); img.src=c.img; img.alt=`${c.name} card`; img.onerror = () => { thumb.textContent = c.name[0]; };
        thumb.appendChild(img);
        const meta = document.createElement('div'); meta.className='meta';
        const name = document.createElement('div'); name.className='name'; name.textContent=c.name;
        const cost = document.createElement('div'); cost.className='cost'; cost.textContent=`Cost: ${c.cost}`;
        meta.appendChild(name); meta.appendChild(cost);
        btn.appendChild(thumb); btn.appendChild(meta);
        cardsRoot.appendChild(btn);
      });
      refreshElixirUI();
    }
    function refreshElixirUI(){
      [...cardsRoot.children].forEach((node, i)=>{
        const c = allCards[hand[i]];
        node.classList.toggle('disabled', elixir.blue < c.cost);
        node.classList.toggle('selected', selectedHandSlot === i);
      });
      elixirFill.style.transform = `scaleX(${elixir.blue/ELIXIR_MAX})`;
      elixirText.textContent = String(Math.floor(elixir.blue));
    }
    function rotateAfterPlay(playedIdx, slot){
      deckOrder = deckOrder.filter(i => i !== playedIdx).concat([playedIdx]);
      const next = deckOrder.find(i => !hand.includes(i));
      if (next !== undefined) hand[slot] = next;
      renderCardBar();
    }

    /* ---------- Towers ---------- */
    function tKing(side, x, y){ return {type:'king', side, x, y, r:26, hp:2000, maxHp:2000, rof:1.0, range:260, cd:0, awake:false}; }
    function tXbow(side, x, y){ return {type:'xbow', side, x, y, r:16,  hp:1000, maxHp:1000, rof:1.0, range:300, cd:0}; }
    const towers = [
      tKing('blue', W/2, H-100),
      tXbow('blue', lanesX[0], H-190),
      tXbow('blue', lanesX[1], H-190),
      tKing('red',  W/2, 100),
      tXbow('red',  lanesX[0], 190),
      tXbow('red',  lanesX[1], 190),
    ];
    function enemySideOf(s){ return s==='blue' ? 'red' : 'blue'; }
    function kingOf(s){ return towers.find(t => t.type==='king' && t.side===s); }
    function aliveCrossbowOn(s, laneX){
      const list = towers.filter(t => t.type==='xbow' && t.side===s && t.hp>0);
      if (!list.length) return null;
      return list.reduce((best, t)=> Math.abs(t.x-laneX)<Math.abs(best.x-laneX)? t:best, list[0]);
    }

    /* ---------- Units / Projectiles / FX ---------- */
    const units = []; // {side,x,y,laneX,hp,maxHp,dmg,atk,cd,range,speed,radius,kind,type,imgSrc}
    const projectiles = []; // {x,y,vx,vy,spd,dmg,target}
    const particles = [];   // {x,y,vx,vy,life,ttl,size,color}
    const floatDMG = [];    // {x,y,vy,life,ttl,text,color}

    function spawnUnits(card, laneX, y){
      for (let i=0;i<card.count;i++){
        const off = (card.count>1? (i===0?-12:12) : 0);
        units.push({
          side:'blue', x: laneX + off, y, laneX,
          hp: card.hp, maxHp: card.hp,
          dmg: card.dmg, atk: card.atk, cd:0,
          range: card.range, speed: card.speed,
          radius: card.radius, kind: card.id, type: card.type,
          imgSrc: card.img
        });
      }
    }

    function spawnBolt(from, target, dmg=30, spd=360){
      const ang = Math.atan2(target.y - from.y, target.x - from.x);
      projectiles.push({ x: from.x, y: from.y, vx: Math.cos(ang), vy: Math.sin(ang), spd, dmg, target });
    }

    function addHitFX(x,y,dmg,color='#ffd166'){
      for(let i=0;i<10;i++){
        const a = Math.random()*Math.PI*2, s = 60 + Math.random()*160;
        particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life:0, ttl:0.35+Math.random()*0.25, size: 2 + Math.random()*2, color });
      }
      floatDMG.push({ x, y: y-8, vy: -40, life:0, ttl:0.8, text: String(Math.round(dmg)), color });
    }

    /* ---------- Helpers ---------- */
    function shuffle(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
    function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim() || '#fff'; }
    const labelFor = k => k==='knight'?'K':k==='archers'?'Ar':'MM';

    function dealDamage(target, amount){
      if (!target || target.hp<=0) return;
      target.hp -= amount;
      const rT = ('r' in target) ? target.r : target.radius;
      addHitFX(target.x, target.y - (rT*0.4), amount, '#ffd166');
      if (target.type === 'king' && !target.awake){ target.awake = true; }
    }

    /* ---------- Drawing ---------- */
    function drawBattlefield(){
      ctx.clearRect(0,0,W,H);

      // Ground halves
      ctx.fillStyle = '#0c1431'; ctx.fillRect(0, 0, W, riverY - riverH/2);
      ctx.fillRect(0, riverY + riverH/2, W, H - (riverY + riverH/2));

      // River
      const grad = ctx.createLinearGradient(0, riverY-riverH/2, 0, riverY+riverH/2);
      grad.addColorStop(0, getCSS('--riverHi')); grad.addColorStop(1, getCSS('--river'));
      ctx.fillStyle = grad; ctx.fillRect(0, riverY - riverH/2, W, riverH);

      // Bridges
      ctx.fillStyle = getCSS('--bridge');
      for (const x of lanesX){
        roundedRect(x - bridgeW/2, riverY - bridgeH/2, bridgeW, bridgeH, 10); ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2;
        for (let i=-3;i<=3;i++){ const bx = x + (i*bridgeW/7); ctx.beginPath(); ctx.moveTo(bx, riverY-bridgeH/2+6); ctx.lineTo(bx, riverY+bridgeH/2-6); ctx.stroke(); }
      }

      // Lane guides
      for (const x of lanesX){
        ctx.strokeStyle = getCSS('--lane'); ctx.lineWidth = 22; ctx.beginPath(); ctx.moveTo(x, 40); ctx.lineTo(x, H-40); ctx.stroke();
        ctx.strokeStyle = getCSS('--laneCtr'); ctx.lineWidth = 2; ctx.setLineDash([8,8]); ctx.beginPath(); ctx.moveTo(x, 40); ctx.lineTo(x, H-40); ctx.stroke(); ctx.setLineDash([]);
      }
    }

    function roundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
    }

    function drawTower(t){
      ctx.save();
      const col = t.side === 'blue' ? getCSS('--blue') : getCSS('--red');

      if (t.type === 'king'){
        ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.ellipse(t.x, t.y+28, 36, 12, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = col; ctx.strokeStyle = '#0a0f25'; ctx.lineWidth = 3; roundedRect(t.x-28, t.y-36, 56, 72, 10); ctx.fill(); ctx.stroke();
        ctx.fillStyle = getCSS('--gold'); ctx.strokeStyle = '#7a5a00'; ctx.beginPath(); const cw=30;
        ctx.moveTo(t.x - cw/2, t.y - 40); ctx.lineTo(t.x - cw/6, t.y - 28); ctx.lineTo(t.x, t.y - 38); ctx.lineTo(t.x + cw/6, t.y - 28); ctx.lineTo(t.x + cw/2, t.y - 40); ctx.closePath(); ctx.fill(); ctx.stroke();
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.ellipse(t.x, t.y+18, 26, 9, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = col; ctx.strokeStyle = '#0a0f25'; ctx.lineWidth = 3; roundedRect(t.x-18, t.y-22, 36, 44, 8); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = '#c9cedd'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(t.x-20, t.y-4); ctx.lineTo(t.x+20, t.y-4); ctx.stroke();
      }

      const maxHP = t.maxHp; const pct = Math.max(0, Math.min(1, t.hp/maxHP));
      const w = 60, h=6, bx=t.x-w/2, by=t.y-(t.type==='king'?52:38);
      ctx.fillStyle='#0a1129'; ctx.fillRect(bx,by,w,h);
      ctx.fillStyle='#6bff95'; ctx.fillRect(bx,by,w*pct,h);
      ctx.strokeStyle='#0a0f25'; ctx.strokeRect(bx,by,w,h);
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillStyle = '#dfe7ff';
      ctx.fillText(Math.max(0, Math.ceil(t.hp)), t.x, by-2);
      ctx.restore();
    }

    function drawUnit(u){
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.45)'; ctx.shadowBlur = 6; ctx.shadowOffsetY = 2;
      ctx.fillStyle = '#eaf4ff'; ctx.beginPath(); ctx.arc(u.x, u.y, u.radius, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
      ctx.lineWidth = 2; ctx.strokeStyle = '#0a1a3d'; ctx.stroke();

      // label
      ctx.font = 'bold 11px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#0b1433';
      ctx.fillText(labelFor(u.kind), u.x, u.y);

      // HP bar + number
      const w=38, h=5, bx=u.x-w/2, by=u.y - (u.radius+10);
      const pct = Math.max(0, Math.min(1, u.hp/u.maxHp));
      ctx.fillStyle='#0a1129'; ctx.fillRect(bx,by,w,h);
      ctx.fillStyle= pct>0.5 ? '#6bff95' : (pct>0.25? '#ffd166' : '#ff7b7b');
      ctx.fillRect(bx,by,w*pct,h);
      ctx.strokeStyle='#0a0f25'; ctx.strokeRect(bx,by,w,h);
      ctx.font='11px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillStyle='#dfe7ff';
      ctx.fillText(Math.max(0, Math.ceil(u.hp)), u.x, by-2);
      ctx.restore();
    }

    function drawProjectiles(){
      ctx.save();
      ctx.fillStyle = '#ffd166';
      ctx.shadowColor = 'rgba(255,209,102,0.6)'; ctx.shadowBlur = 8;
      for (const p of projectiles){ ctx.beginPath(); ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function drawFX(){
      ctx.save();
      // particles
      for (const p of particles){
        const a = 1 - (p.life/p.ttl); if (a <= 0) continue;
        ctx.globalAlpha = a; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
      }
      // damage numbers
      for (const f of floatDMG){
        const a = 1 - (f.life/f.ttl); if (a <= 0) continue;
        ctx.globalAlpha = a; ctx.font = 'bold 14px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle = f.color; ctx.fillText(f.text, f.x, f.y);
      }
      ctx.restore();
    }

    /* ---------- AI / Updates ---------- */
    function xbowBandFor(t){ return (t.side==='blue') ? { yMin: riverY + riverH/2, yMax: H } : { yMin: 0, yMax: riverY - riverH/2 }; }
    function enemyUnits(side){ return units.filter(u => u.side !== side && u.hp>0); }
    function enemyTowers(side){ return towers.filter(t => t.side !== side && t.hp>0); }

    function towerAI(t, dt){
      if (t.hp <= 0) return;
      if (t.type==='king' && !t.awake) return;
      t.cd -= dt; if (t.cd > 0) return;

      let candidates = enemyUnits(t.side);
      if (t.type==='xbow'){ const band = xbowBandFor(t); candidates = candidates.filter(e => e.y >= band.yMin && e.y <= band.yMax); }
      candidates = candidates.filter(e => dist(t,e) < t.range);

      if (!candidates.length){
        let ets = enemyTowers(t.side);
        if (t.type==='xbow'){ const band = xbowBandFor(t); ets = ets.filter(e => e.y >= band.yMin && e.y <= band.yMax); }
        ets = ets.filter(e => dist(t,e) < t.range);
        candidates = ets;
      }

      let best=null, bestD=1e9;
      for (const e of candidates){ const d = dist(t,e); if (d < bestD){ best=e; bestD=d; } }
      if (best){ spawnBolt(t, best, (t.type==='king'?50:30), (t.type==='king'?340:380)); t.cd = t.rof; }
    }

    function unitUpdate(u, dt){
      if (u.hp<=0) return;
      const foe = enemySideOf(u.side);
      let struct = aliveCrossbowOn(foe, u.laneX) || kingOf(foe);

      let close = enemyUnits(u.side).filter(e => dist(u,e) <= (u.type==='melee' ? (u.radius + e.radius + 2) : u.range));
      if (!close.length && struct){
        const inR = dist(u,struct) <= (u.type==='melee' ? (u.radius + struct.r + 2) : u.range);
        if (inR) close = [struct];
      }

      let best=null, bestD=1e9; for (const e of close){ const d=dist(u,e); if (d<bestD){ best=e; bestD=d; } }

      const moveTarget = best || struct;
      if (moveTarget){
        const dx = moveTarget.x - u.x, dy = moveTarget.y - u.y, len = Math.hypot(dx,dy) || 1;
        const nx = dx/len, ny = dy/len; const tgtR = ('r' in moveTarget) ? moveTarget.r : moveTarget.radius;
        const need = (u.type==='melee') ? (tgtR + u.radius + 2) : u.range;
        const dNow = dist(u, moveTarget);
        if (dNow > need){ const step = u.speed * dt; const s = (dNow - step < need) ? Math.max(0, dNow - need) : step; u.x += nx*s; u.y += ny*s; }
      } else { u.y -= u.speed * dt; }

      u.x += (u.laneX - u.x) * Math.min(1, dt*6);

      u.cd -= dt;
      if (best && u.cd<=0){ dealDamage(best, u.dmg); u.cd = u.atk; }
      else if (!best && struct && u.cd<=0){
        const d = dist(u, struct), need = (u.type==='melee') ? (struct.r + u.radius + 2) : u.range;
        if (d <= need){ dealDamage(struct, u.dmg); u.cd = u.atk; }
      }
    }

    function updateProjectiles(dt){
      for (const p of projectiles){
        const tgt = p.target;
        if (!tgt || tgt.hp <= 0) { p.dead = true; continue; }
        const dirx = tgt.x - p.x, diry = tgt.y - p.y, len = Math.hypot(dirx, diry) || 1;
        p.vx = dirx/len; p.vy = diry/len; p.x += p.vx * p.spd * dt; p.y += p.vy * p.spd * dt;
        const rT = ('r' in tgt) ? tgt.r : tgt.radius;
        if (Math.hypot(tgt.x - p.x, tgt.y - p.y) <= (rT+6)){ dealDamage(tgt, p.dmg); p.dead = true; }
      }
      for (let i=projectiles.length-1;i>=0;i--) if (projectiles[i].dead) projectiles.splice(i,1);
    }

    function updateFX(dt){
      for (const p of particles){ p.life += dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.94; p.vy *= 0.94; }
      for (let i=particles.length-1;i>=0;i--) if (particles[i].life>particles[i].ttl) particles.splice(i,1);
      for (const f of floatDMG){ f.life += dt; f.y += f.vy*dt; f.vy *= 0.98; }
      for (let i=floatDMG.length-1;i>=0;i--) if (floatDMG[i].life>floatDMG[i].ttl) floatDMG.splice(i,1);
    }

    function drawAll(){
      drawBattlefield();
      for (const t of towers) drawTower(t);
      for (const u of units)  drawUnit(u);
      drawProjectiles();
      drawFX();
    }

    /* ---------- Main Loop ---------- */
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, Math.max(0, (now - last) / 1000)); last = now;

      elixir.blue = Math.min(ELIXIR_MAX, elixir.blue + ELIXIR_PER_SEC*dt);
      refreshElixirUI();

      for (const t of towers) towerAI(t, dt);
      for (const u of units) unitUpdate(u, dt);
      for (let i=units.length-1;i>=0;i--) if (units[i].hp<=0) units.splice(i,1);

      updateProjectiles(dt);
      updateFX(dt);
      drawAll();

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /* ---------- Deployment ---------- */
    function canvasPoint(ev){
      const r = canv.getBoundingClientRect();
      return { x: (ev.clientX - r.left) * (canv.width / r.width), y: (ev.clientY - r.top) * (canv.height / r.height) };
    }
    canv.addEventListener('click', (ev)=>{
      if (selectedHandSlot===null) return;
      const {x:mx, y:my} = canvasPoint(ev);
      const halfMin = riverY + riverH/2 + 20, halfMax = H - 40;
      if (my < halfMin || my > halfMax) return;

      const laneX = Math.abs(mx - lanesX[0]) < Math.abs(mx - lanesX[1]) ? lanesX[0] : lanesX[1];
      const spawnY = Math.max(halfMin+10, Math.min(halfMax, my));

      const idx = hand[selectedHandSlot]; const card = allCards[idx];
      if (!card || elixir.blue < card.cost) return;

      elixir.blue -= card.cost;
      spawnUnits(card, laneX, spawnY);
      rotateAfterPlay(idx, selectedHandSlot);
      selectedHandSlot = null;
      refreshElixirUI();
    });

    /* ---------- Init ---------- */
    renderCardBar();
  });
  </script>
</body>
</html>
